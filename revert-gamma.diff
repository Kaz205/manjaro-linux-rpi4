diff -ruP a/drivers/gpu/drm/vc4/vc4_crtc.c b/drivers/gpu/drm/vc4/vc4_crtc.c
--- a/drivers/gpu/drm/vc4/vc4_crtc.c	2021-11-22 14:41:48.078953000 -0600
+++ b/drivers/gpu/drm/vc4/vc4_crtc.c	2021-11-22 09:40:48.040074000 -0600
@@ -292,23 +292,6 @@
 	return NULL;
 }
 
-#define drm_for_each_connector_mask(connector, dev, connector_mask) \
-	list_for_each_entry((connector), &(dev)->mode_config.connector_list, head) \
-		for_each_if ((connector_mask) & drm_connector_mask(connector))
-
-struct drm_connector *vc4_get_crtc_connector(struct drm_crtc *crtc,
-					     struct drm_crtc_state *state)
-{
-	struct drm_connector *connector;
-
-	WARN_ON(hweight32(state->connector_mask) > 1);
-
-	drm_for_each_connector_mask(connector, crtc->dev, state->connector_mask)
-		return connector;
-
-	return NULL;
-}
-
 static void vc4_crtc_pixelvalve_reset(struct drm_crtc *crtc)
 {
 	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
@@ -1209,42 +1192,19 @@
 
 	if (!vc4->hvs->hvs5) {
 		drm_mode_crtc_set_gamma_size(crtc, ARRAY_SIZE(vc4_crtc->lut_r));
-	} else {
-		/* This is a lie for hvs5 which uses a 16 point PWL, but it
-		 * allows for something smarter than just 16 linearly spaced
-		 * segments. Conversion is done in vc5_hvs_update_gamma_lut.
-		 */
-		drm_mode_crtc_set_gamma_size(crtc, 256);
-	}
 
-	drm_crtc_enable_color_mgmt(crtc, 0, false, crtc->gamma_size);
+		drm_crtc_enable_color_mgmt(crtc, 0, false, crtc->gamma_size);
 
-	if (!vc4->hvs->hvs5) {
 		/* We support CTM, but only for one CRTC at a time. It's therefore
 		 * implemented as private driver state in vc4_kms, not here.
 		 */
-		drm_crtc_enable_color_mgmt(crtc, 0, true, 0);
+		drm_crtc_enable_color_mgmt(crtc, 0, true, crtc->gamma_size);
+	}
 
-		/* Initialize the VC4 gamma LUTs */
-		for (i = 0; i < crtc->gamma_size; i++) {
-			vc4_crtc->lut_r[i] = i;
-			vc4_crtc->lut_g[i] = i;
-			vc4_crtc->lut_b[i] = i;
-		}
-	} else {
-		/* Initialize the VC5 gamma PWL entries. Assume 12-bit pipeline,
-		 * evenly spread over full range.
-		 */
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++) {
-			vc4_crtc->pwl_r[i] =
-				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
-			vc4_crtc->pwl_g[i] =
-				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
-			vc4_crtc->pwl_b[i] =
-				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
-			vc4_crtc->pwl_a[i] =
-				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
-		}
+	for (i = 0; i < crtc->gamma_size; i++) {
+		vc4_crtc->lut_r[i] = i;
+		vc4_crtc->lut_g[i] = i;
+		vc4_crtc->lut_b[i] = i;
 	}
 
 	return 0;
diff -ruP a/drivers/gpu/drm/vc4/vc4_drv.h b/drivers/gpu/drm/vc4/vc4_drv.h
--- a/drivers/gpu/drm/vc4/vc4_drv.h	2021-11-22 14:41:48.082953000 -0600
+++ b/drivers/gpu/drm/vc4/vc4_drv.h	2021-11-22 09:40:48.032074000 -0600
@@ -19,7 +19,6 @@
 #include <drm/drm_modeset_lock.h>
 
 #include "uapi/drm/vc4_drm.h"
-#include "vc4_regs.h"
 
 struct drm_device;
 struct drm_gem_object;
@@ -483,17 +482,6 @@
 
 };
 
-struct vc5_gamma_entry {
-	u32 x_c_terms;
-	u32 grad_term;
-};
-
-#define VC5_HVS_SET_GAMMA_ENTRY(x, c, g) (struct vc5_gamma_entry){	\
-	.x_c_terms = VC4_SET_FIELD((x), SCALER5_DSPGAMMA_OFF_X) | 	\
-		     VC4_SET_FIELD((c), SCALER5_DSPGAMMA_OFF_C),	\
-	.grad_term = (g)						\
-}
-
 struct vc4_crtc {
 	struct drm_crtc base;
 	struct platform_device *pdev;
@@ -503,19 +491,9 @@
 	/* Timestamp at start of vblank irq - unaffected by lock delays. */
 	ktime_t t_vblank;
 
-	union {
-		struct {  /* VC4 gamma LUT */
-			u8 lut_r[256];
-			u8 lut_g[256];
-			u8 lut_b[256];
-		};
-		struct {  /* VC5 gamma PWL entries */
-			struct vc5_gamma_entry pwl_r[SCALER5_DSPGAMMA_NUM_POINTS];
-			struct vc5_gamma_entry pwl_g[SCALER5_DSPGAMMA_NUM_POINTS];
-			struct vc5_gamma_entry pwl_b[SCALER5_DSPGAMMA_NUM_POINTS];
-			struct vc5_gamma_entry pwl_a[SCALER5_DSPGAMMA_NUM_POINTS];
-		};
-	};
+	u8 lut_r[256];
+	u8 lut_g[256];
+	u8 lut_b[256];
 
 	struct drm_pending_vblank_event *event;
 
@@ -569,9 +547,6 @@
 	return container_of(data, struct vc4_pv_data, base);
 }
 
-struct drm_connector *vc4_get_crtc_connector(struct drm_crtc *crtc,
-					     struct drm_crtc_state *state);
-
 struct drm_encoder *vc4_get_crtc_encoder(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state);
 
diff -ruP a/drivers/gpu/drm/vc4/vc4_hvs.c b/drivers/gpu/drm/vc4/vc4_hvs.c
--- a/drivers/gpu/drm/vc4/vc4_hvs.c	2021-11-22 14:41:48.082953000 -0600
+++ b/drivers/gpu/drm/vc4/vc4_hvs.c	2021-11-22 09:40:48.028074000 -0600
@@ -134,84 +134,6 @@
 	return 0;
 }
 
-static int vc5_hvs_debugfs_gamma(struct seq_file *m, void *data)
-{
-	struct drm_info_node *node = m->private;
-	struct drm_device *dev = node->minor->dev;
-	struct vc4_dev *vc4 = to_vc4_dev(dev);
-	struct drm_printer p = drm_seq_file_printer(m);
-	unsigned int i, chan;
-	u32 dispstat, dispbkgndx;
-
-	for (chan = 0; chan < SCALER_CHANNELS_COUNT; chan++) {
-		u32 x_c, grad;
-		u32 offset = SCALER5_DSPGAMMA_START +
-			chan * SCALER5_DSPGAMMA_CHAN_OFFSET;
-
-		dispstat = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTATX(chan)),
-					 SCALER_DISPSTATX_MODE);
-		if (dispstat == SCALER_DISPSTATX_MODE_DISABLED ||
-		    dispstat == SCALER_DISPSTATX_MODE_EOF) {
-			drm_printf(&p, "HVS channel %u: Channel disabled\n", chan);
-			continue;
-		}
-
-		dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(chan));
-		if (!(dispbkgndx & SCALER_DISPBKGND_GAMMA)) {
-			drm_printf(&p, "HVS channel %u: Gamma disabled\n", chan);
-			continue;
-		}
-
-		drm_printf(&p, "HVS channel %u:\n", chan);
-		drm_printf(&p, "  red:\n");
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
-			x_c = HVS_READ(offset);
-			grad = HVS_READ(offset + 4);
-			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
-				   x_c, grad,
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
-				   grad);
-		}
-		drm_printf(&p, "  green:\n");
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
-			x_c = HVS_READ(offset);
-			grad = HVS_READ(offset + 4);
-			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
-				   x_c, grad,
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
-				   grad);
-		}
-		drm_printf(&p, "  blue:\n");
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
-			x_c = HVS_READ(offset);
-			grad = HVS_READ(offset + 4);
-			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
-				   x_c, grad,
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
-				   grad);
-		}
-
-		/* Alpha only valid on channel 2 */
-		if (chan != 2)
-			continue;
-
-		drm_printf(&p, "  alpha:\n");
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
-			x_c = HVS_READ(offset);
-			grad = HVS_READ(offset + 4);
-			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
-				   x_c, grad,
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
-				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
-				   grad);
-		}
-	}
-	return 0;
-}
-
 /* The filter kernel is composed of dwords each containing 3 9-bit
  * signed integers packed next to each other.
  */
@@ -314,80 +236,6 @@
 	vc4_hvs_lut_load(crtc);
 }
 
-static void vc5_hvs_write_gamma_entry(struct vc4_dev *vc4,
-				      u32 offset,
-				      struct vc5_gamma_entry *gamma)
-{
-	HVS_WRITE(offset, gamma->x_c_terms);
-	HVS_WRITE(offset + 4, gamma->grad_term);
-}
-
-static void vc5_hvs_lut_load(struct drm_crtc *crtc)
-{
-	struct drm_device *dev = crtc->dev;
-	struct vc4_dev *vc4 = to_vc4_dev(dev);
-	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
-	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);
-	u32 i;
-	u32 offset = SCALER5_DSPGAMMA_START +
-		vc4_state->assigned_channel * SCALER5_DSPGAMMA_CHAN_OFFSET;
-
-	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
-		vc5_hvs_write_gamma_entry(vc4, offset, &vc4_crtc->pwl_r[i]);
-	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
-		vc5_hvs_write_gamma_entry(vc4, offset, &vc4_crtc->pwl_g[i]);
-	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
-		vc5_hvs_write_gamma_entry(vc4, offset, &vc4_crtc->pwl_b[i]);
-
-	if (vc4_state->assigned_channel == 2) {
-		/* Alpha only valid on channel 2 */
-		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
-			vc5_hvs_write_gamma_entry(vc4, offset, &vc4_crtc->pwl_a[i]);
-	}
-}
-
-static void vc5_hvs_update_gamma_lut(struct drm_crtc *crtc)
-{
-	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
-	struct drm_color_lut *lut = crtc->state->gamma_lut->data;
-	unsigned int step, i;
-	u32 start, end;
-
-#define VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl, chan)			\
-	start = drm_color_lut_extract(lut[i * step].chan, 12);		\
-	end = drm_color_lut_extract(lut[(i + 1) * step - 1].chan, 12);	\
-									\
-	/* Negative gradients not permitted by the hardware, so		\
-	 * flatten such points out.					\
-	 */								\
-	if (end < start)						\
-		end = start;						\
-									\
-	/* Assume 12bit pipeline.					\
-	 * X evenly spread over full range (12 bit).			\
-	 * C as U12.4 format.						\
-	 * Gradient as U4.8 format.					\
-	*/								\
-	vc4_crtc->pwl[i] =						\
-		VC5_HVS_SET_GAMMA_ENTRY(i << 8, start << 4,		\
-				((end - start) << 4) / (step - 1))
-
-	/* HVS5 has a 16 point piecewise linear function for each colour
-	 * channel (including alpha on channel 2) on each display channel.
-	 *
-	 * Currently take a crude subsample of the gamma LUT, but this could
-	 * be improved to implement curve fitting.
-	 */
-	step = crtc->gamma_size / SCALER5_DSPGAMMA_NUM_POINTS;
-	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++) {
-		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_r, red);
-		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_g, green);
-		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_b, blue);
-	}
-
-	vc5_hvs_lut_load(crtc);
-}
-
 int vc4_hvs_get_fifo_from_output(struct drm_device *dev, unsigned int output)
 {
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
@@ -480,21 +328,15 @@
 	dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
 	dispbkgndx &= ~SCALER_DISPBKGND_INTERLACE;
 
-	if (crtc->state->gamma_lut)
-		/* Enable gamma on if required */
-		dispbkgndx |= SCALER_DISPBKGND_GAMMA;
-
 	HVS_WRITE(SCALER_DISPBKGNDX(chan), dispbkgndx |
 		  SCALER_DISPBKGND_AUTOHS |
+		  ((!vc4->hvs->hvs5) ? SCALER_DISPBKGND_GAMMA : 0) |
 		  (interlace ? SCALER_DISPBKGND_INTERLACE : 0));
 
 	/* Reload the LUT, since the SRAMs would have been disabled if
 	 * all CRTCs had SCALER_DISPBKGND_GAMMA unset at once.
 	 */
-	if (!vc4->hvs->hvs5)
-		vc4_hvs_lut_load(crtc);
-	else
-		vc5_hvs_lut_load(crtc);
+	vc4_hvs_lut_load(crtc);
 
 	return 0;
 }
@@ -523,46 +365,6 @@
 		     SCALER_DISPSTATX_EMPTY);
 }
 
-static int vc4_hvs_gamma_check(struct drm_crtc *crtc,
-			       struct drm_atomic_state *state)
-{
-	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
-	struct drm_connector_state *conn_state;
-	struct drm_connector *connector;
-	struct drm_device *dev = crtc->dev;
-	struct vc4_dev *vc4 = to_vc4_dev(dev);
-
-	if (!vc4->hvs->hvs5)
-		return 0;
-
-	if (!crtc_state->color_mgmt_changed)
-		return 0;
-
-	if (crtc_state->gamma_lut) {
-		unsigned int len = drm_color_lut_size(crtc_state->gamma_lut);
-
-		if (len != crtc->gamma_size) {
-			DRM_DEBUG_KMS("Invalid LUT size; got %u, expected %u\n",
-				      len, crtc->gamma_size);
-			return -EINVAL;
-		}
-	}
-
-	connector = vc4_get_crtc_connector(crtc, crtc_state);
-	if (!connector)
-		return -EINVAL;
-
-	if (!(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))
-		return 0;
-
-	conn_state = drm_atomic_get_connector_state(state, connector);
-	if (!conn_state)
-		return -EINVAL;
-
-	crtc_state->mode_changed = true;
-	return 0;
-}
-
 int vc4_hvs_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)
 {
 	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
@@ -593,7 +395,7 @@
 	if (ret)
 		return ret;
 
-	return vc4_hvs_gamma_check(crtc, state);
+	return 0;
 }
 
 static void vc4_hvs_update_dlist(struct drm_crtc *crtc)
@@ -732,25 +534,14 @@
 		u32 dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(vc4_state->assigned_channel));
 
 		if (crtc->state->gamma_lut) {
-			if (!vc4->hvs->hvs5) {
-				vc4_hvs_update_gamma_lut(crtc);
-				dispbkgndx |= SCALER_DISPBKGND_GAMMA;
-			} else {
-				vc5_hvs_update_gamma_lut(crtc);
-			}
+			vc4_hvs_update_gamma_lut(crtc);
+			dispbkgndx |= SCALER_DISPBKGND_GAMMA;
 		} else {
 			/* Unsetting DISPBKGND_GAMMA skips the gamma lut step
 			 * in hardware, which is the same as a linear lut that
 			 * DRM expects us to use in absence of a user lut.
-			 *
-			 * Do NOT change state dynamically for hvs5 as it
-			 * inserts a delay in the pipeline that will cause
-			 * stalls if enabled/disabled whilst running. The other
-			 * should already be disabling/enabling the pipeline
-			 * when gamma changes.
 			 */
-			if (!vc4->hvs->hvs5)
-				dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
+			dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
 		}
 		HVS_WRITE(SCALER_DISPBKGNDX(vc4_state->assigned_channel), dispbkgndx);
 	}
@@ -939,9 +730,6 @@
 			     NULL);
 	vc4_debugfs_add_file(drm, "hvs_dlists", vc4_hvs_debugfs_dlist,
 			     NULL);
-	if (hvs->hvs5)
-		vc4_debugfs_add_file(drm, "hvs_gamma", vc5_hvs_debugfs_gamma,
-				     NULL);
 
 	return 0;
 }
diff -ruP a/drivers/gpu/drm/vc4/vc4_regs.h b/drivers/gpu/drm/vc4/vc4_regs.h
--- a/drivers/gpu/drm/vc4/vc4_regs.h	2021-11-03 13:13:31.096907000 -0500
+++ b/drivers/gpu/drm/vc4/vc4_regs.h	2021-11-22 09:40:47.764077000 -0600
@@ -491,28 +491,6 @@
 #define SCALER_DLIST_START                      0x00002000
 #define SCALER_DLIST_SIZE                       0x00004000
 
-/* Gamma PWL for each channel. 16 points for each of 4 colour channels (alpha
- * only on channel 2). 8 bytes per entry, offsets first, then gradient:
- *   Y = GRAD * X + C
- *
- * Values for X and C are left justified, and vary depending on the width of
- * the HVS channel:
- *    8-bit pipeline: X uses [31:24], C is U8.8 format, and GRAD is U4.8.
- *   12-bit pipeline: X uses [31:20], C is U12.4 format, and GRAD is U4.8.
- *
- * The 3 HVS channels start at 0x400 offsets (ie chan 1 starts at 0x2400, and
- * chan 2 at 0x2800).
- */
-#define SCALER5_DSPGAMMA_NUM_POINTS		16
-#define SCALER5_DSPGAMMA_START			0x00002000
-#define SCALER5_DSPGAMMA_CHAN_OFFSET		0x400
-# define SCALER5_DSPGAMMA_OFF_X_MASK		VC4_MASK(31, 20)
-# define SCALER5_DSPGAMMA_OFF_X_SHIFT		20
-# define SCALER5_DSPGAMMA_OFF_C_MASK		VC4_MASK(15, 0)
-# define SCALER5_DSPGAMMA_OFF_C_SHIFT		0
-# define SCALER5_DSPGAMMA_GRAD_MASK		VC4_MASK(11, 0)
-# define SCALER5_DSPGAMMA_GRAD_SHIFT		0
-
 #define SCALER5_DLIST_START			0x00004000
 
 # define VC4_HDMI_SW_RESET_FORMAT_DETECT	BIT(1)
